+++
author = "zenk"
slug = ""
tags = ["编程","设计"]
draft = true
categories=["cs"]
title="常用面向对象设计原则"
description="常用的面向对象设计原则，SOILD"
date="2018-07-04T22:28:20+08:00"
+++

## 设计

目的TODO

坏味道

## 单一职责原则

又名SRP(Single Responsibility Principle)。针对一个函数、类、组件、架构的修改有且只有一个理由，而理由的来自于使用者。

这样的好处是把拥有相同修改理由的函数、类、组件组织在一起，不同的分开，达到修改的时候不会影响其他代码，增强了可维护性。

这是一个定义简单，实操不容易正确的原则。原因在于：

1. **职责**无法度量。
2. 因为团队、项目背景等待原因，在具体实现的细节中很难做到SRP。

因此，在设计的时候接口一定做到SRP，实现尽量SRP。

**注：**

组件层面的SRP，叫做Component common closure，架构层面的SRP叫做axis of change responsibility for creation of architecture boundary。

## 开闭原则

又名OCP（Open-Close Principle）。对扩展开发，对修改关闭。

通过这样的方式达到添加一个功能时，尽可能少的修改现有源代码、模块、二进制文件，尽可能的通过添加代码来实现。这样减少原来的功能被破坏的概率，达到软件的可维护性、可扩展性、可复用性。因此，它是其他面向对象设计原则的核心。

遵守OCP原则的手段是**抽象**。一个功能的抽象，更依赖于使用者，而非实现者。只有使用者才明白需要抽象什么内容。抽象的难点是找到易变的部分，一个指导原则是“快速失败，下不为例”，有以下几条参考实践：
1. TDD，先写测试代码。
2. 更短的开发周期。
3. 先开发特性，后开发基础设施代码，并经常给使用者review。
4. 先开发重要功能。
5. 经常并尽早发布，尽可能让用户和使用者使用。

抽象的对象一般是类、模块以及组件。几个比较的好的实践：
1. 在函数参数、类抽象中提供稳定的接口定义。
2. 通过元数据抽象逻辑，比如通过配置的形式表达逻辑。
3. 定义项目章程，建立团队文化，沉淀优秀的习惯，提高开发效率。
4. 在架构层面，分析功能变化的来源、时机以及原因，把功能划分为不同的组件，底层组件依赖高层组件，高层组件不会受到底层组件变化的影响，同时避免循环依赖。

抽象的时候需要避免过度抽象，带来不必要的复杂度。

## 里氏替换原则

TODO

## 结论

原则用到的工具抽象TODO，抽象变化

各个原则之间的关系，理由，总结TODO